import warnings
from glob import glob
from os.path import *

import pandas as pd
from ete3 import Tree
import arviz as az
from tqdm import tqdm
import os,io


def cal_ESS(df,burn_in=2000):
    """
    generate effective sample size (ESS) of given dataframe.
    The method 'identity' is the most similar method to the ESS generated by BEAST.

    Args:
        df (pd.DataFrame): [description]
        burn_in (int, optional): [description]. Defaults to 2000.
    """
    col2ESS = {}
    for colname,col in df.iteritems():
        vals = col.values[burn_in:]
        col2ESS[colname] = az.ess(vals,method='identity')
    return col2ESS

def cal_HPD_CI(df,burn_in=2000):
    """
    get HPD CI through mcmc.txt directly instead of reading the log/out file.
    Only calculate high density probility 95%. 
    Args:
        df (pd.DataFrame): [description]
        burn_in (int, optional): [description]. Defaults to 2000.
    """
    col2CI = {}
    for colname,col in df.iteritems():
        vals = col.values[burn_in:]
        col2CI[colname] = az.hdi(vals,hdi_prob=.95)
    return col2CI


def parse_row(r):
    r = [_.strip("(),") for _ in r.split(' ') if _.strip("(),")]
    r = f"{r[0]}\t{r[1]}\t{r[4]}\t{r[5]}\t{r[6]}"
    return r
    
def read_mcmc(mcmc,all_col=False):
    if type(mcmc) != str:
        return mcmc
    if all_col:
        mcmc_df = pd.read_csv(mcmc, sep='\t', index_col=0)
    else:
        f1 = open(mcmc)
        header = [_ for _ in next(f1).strip().split('\t')]
        r_header = [_ for _ in header if not _.startswith('r_g')]
        # normally it need to iterate rows and ignore the columns representing rates
        text = '\t'.join(r_header)+'\n'
        r_header=set(r_header)
        for row in f1:
            text += '\t'.join([r for r,h in zip(row.strip().split('\t'),header) if h in r_header])+'\n'  
        mcmc_df = pd.read_csv(io.StringIO(text), sep='\t', index_col=0)   
    return mcmc_df

def read_multi_mcmc(mcmc_list,
                    rename_f=lambda x: basename(dirname(x)).replace('_prior', '').split('_')[-1]):
    df_list = []
    CIs_dict = {}
    for mcmc in tqdm(mcmc_list):
        line = os.popen(f"wc -l {mcmc}").read().split(' ')[0]
        if line!='20002':
            continue
        name = rename_f(mcmc)
        _df = read_mcmc(mcmc)
        _df = _df.reindex(columns=[_ for _ in _df.columns if _.startswith('t_n')])
        df_list.append((name, _df))
        CIs_dict[name] = get_posterior_df(_df,scale=100)
    df_dict = dict(df_list)
    return df_dict, CIs_dict

def get_tre(mcmc):
    each_dir = dirname(mcmc)
    logfile = glob(join(each_dir, '*.log'))
    logfile = [_ for _ in logfile if 'slurm' not in _][0]
    t = get_node_name_from_log(logfile)  # get the tree with internal node name     
    return t

def read_result_CI(logfile):
    marker ="Posterior means (95% Equal-tail CI) (95% HPD CI) HPD-CI-width"
    rows = open(logfile).read().split('\n')
    if marker not in rows:
        print(f"{logfile} doesn't finished")
        return
    idx = rows.index(marker)
    rows = rows[idx+2:]
    _rows = []
    for r in rows:
        if not r:
            break
        _rows.append(r)
    rows = [parse_row(_) for _ in _rows]
    mcmc_df = pd.read_csv(io.StringIO('\n'.join(rows)), sep='\t')
    mcmc_df.columns=['Name','Posterior means','95%HPD CI min','95%HPD CI max','95%HPD CI width']
    return mcmc_df
    

def get_posterior_df(mcmc,burn_in=2000,scale=1,all_col=True):
    mcmc_df = read_mcmc(mcmc,all_col=all_col)
    if pd.isna(mcmc_df.iloc[-1,-1]):
        # if not completed
        mcmc_df = mcmc_df.drop(mcmc_df.index[-1])
    mcmc_df = mcmc_df.loc[~mcmc_df.isna().any(1),:]
    node_names = [_ for _ in mcmc_df.columns if _.startswith('t_n')]
    rates = [_ for _ in mcmc_df.columns if _.startswith('r_g')]
    paras = [_ for _ in mcmc_df.columns if _.startswith('mu') or _.startswith('sigma2')]
    
    post_df = pd.DataFrame(columns=['Posterior mean time (100 Ma)',
                                    'CI_width','CIs'],
                           index=node_names )
    raw_n2CI = cal_HPD_CI(mcmc_df,burn_in=burn_in)
    if 'lnL' in mcmc_df.columns:
        post_df.loc['lnL',:] = 'NA'
        post_df.loc['lnL',:] = [round(mcmc_df.loc[:,'lnL'].mean(),2),
                                round(raw_n2CI['lnL'][1]-raw_n2CI['lnL'][0] ,2),
                                f"{round(raw_n2CI['lnL'][0],2)} - {round(raw_n2CI['lnL'][1],2)}",
                                ]
    
    n2CI = {k: f"{round(v[0]*scale,2)} - {round(v[1]*scale,2)}" 
            for k,v in raw_n2CI.items()}
    n2mean_time = {k:round(v*scale,2) 
                   for k,v in mcmc_df.mean().to_dict().items()}
    
    post_df.loc[node_names,'Posterior mean time (100 Ma)'] = [n2mean_time[_] 
                                                              for _ in post_df.index 
                                                              if _ !='lnL']
    post_df.loc[node_names,'CIs'] = [n2CI[_] 
                                     for _ in post_df.index 
                                     if _ !='lnL']
    post_df.loc[node_names,'CI_width'] = [raw_n2CI[_][1]*scale-raw_n2CI[_][0]*scale 
                                          for _ in post_df.index 
                                          if _ !='lnL']    
    return post_df
    
    
def get_node_name_from_log(f):
    # f should be the *.log file
    rows = open(f).read().split('\n')
    idx = [_ for _,r in enumerate(rows) if r == 'Species tree']
    if not idx:
        print("prior not complete")
        return
    idx = idx[0]
    start_idx = idx +3 
    end_idx = 0
    for _ in range(idx,100000):
        if rows[_] == '':
            end_idx = _
            break
    tree_idx1 = end_idx + 1
    tree_idx2 = end_idx + 2
    # find the index
    n2father = {}
    for i in range(start_idx,end_idx):
        row = [_ for _ in rows[i].split(' ') if _]
        father,n,name = row[0],row[1],row[2]
        n2father[name if len(row)==4 else n ] = father
            
    t = Tree(rows[tree_idx2], format=8)
    for l in t.traverse('postorder'):
        if l.up is None:
            break
        if not l.up.name:
            l.up.name = n2father[l.name]
    return t

def format_figtree(mcmc, name, tree,tree_format=8):
    figtree = dirname(mcmc) + "/FigTree.tre"
    ofile = f"{dirname(mcmc)}/{name}.newick"
    if not exists(figtree) or exists(ofile):
        return
    tree, f = tree,tree_format
    cmd = f"python3 ~/script/evol_tk/dating_workflow/figtree2itol.py -i {tree} -i2 {figtree} -o {ofile} -f {f} ; "
    return cmd