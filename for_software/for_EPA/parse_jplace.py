import json,re
from ete3 import Tree

def get_node_name_from_part(partial_text):
    splited_r = re.split("[,()]",partial_text)
    node_name = splited_r[-1]
        
        
    if "{" in node_name:
        return node_name.split('{')[0]
    return node_name

def parse_tree_with_edges(tree_with_edges):
    node_name2edge_num = {}
    colon_sep = tree_with_edges.split(':')
    for each_part in colon_sep:
        node_name = get_node_name_from_part(each_part)
        if node_name == ';':
            node_name = 'Root'
        if not "{" in each_part:
            node_name2edge_num[node_name] = 0
        else:
            edge_num = re.findall("\{([0-9]+)\}",each_part)
            edge_num = edge_num[0]
            node_name2edge_num[node_name] = int(edge_num)+1  # apart from 1
        
    removed_tree = re.sub("\{[0-9]+\}","",tree_with_edges)
    t = Tree(removed_tree,format=1)
    return t,node_name2edge_num


def parse_placement(placement):
    genome2edge = {}
    for d in placement:
        genome = d['n'][0]
        edge = d['p'][0][0]
        genome2edge[genome] = edge
    return genome2edge

def read_jplace(jplace_file):
    # the placements generated by apples aren't reliable
    obj = json.load(open(jplace_file))
    placement_actions = obj['placements']
    genome2edge = parse_placement(placement_actions)
    used_tree = obj["tree"]
    tree,node_name2edge_num = parse_tree_with_edges(used_tree)
    edge_num2node_name = {v:k for k,v in node_name2edge_num.items()}

    name2node = {n.name:n for n in tree.traverse()}
    genome2new_n = {}
    for genome,edge_num in genome2edge.items():
        node_name = edge_num2node_name[edge_num]

        node = name2node[node_name]
        node.add_sister(name=genome)
        genome2new_n[genome] = node
    return tree